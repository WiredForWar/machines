/*
 * A L G O R I T H M . C T F
 * (c) Charybdis Limited, 1995. All Rights Reserved.
 */

#ifndef _INLINE
    #include "stdlib/algorith.itf"
#endif

//////////////////////////////////////////////////////////////////////

template <class RandomAccessIterator, class Distance, class T>
void __push_heap(RandomAccessIterator first, Distance holeIndex,
		 Distance topIndex, T value) {
    Distance parent = (holeIndex - 1) / 2;
    while (holeIndex > topIndex && *(first + parent) < value) {
	*(first + holeIndex) = *(first + parent);
	holeIndex = parent;
	parent = (holeIndex - 1) / 2;
    }    
    *(first + holeIndex) = value;
}

template <class RandomAccessIterator, class Distance, class T, class Compare>
void __push_heap(RandomAccessIterator first, Distance holeIndex,
		 Distance topIndex, T value, Compare comp) {
    Distance parent = (holeIndex - 1) / 2;
    while (holeIndex > topIndex && comp(*(first + parent), value)) {
	*(first + holeIndex) = *(first + parent);
	holeIndex = parent;
	parent = (holeIndex - 1) / 2;
    }
    *(first + holeIndex) = value;
}

template <class RandomAccessIterator, class Distance, class T>
void __adjust_heap(RandomAccessIterator first, Distance holeIndex,
		   Distance len, T value) {
    Distance topIndex = holeIndex;
    Distance secondChild = 2 * holeIndex + 2;
    while (secondChild < len) {
	if (*(first + secondChild) < *(first + (secondChild - 1)))
	    secondChild--;
	*(first + holeIndex) = *(first + secondChild);
	holeIndex = secondChild;
	secondChild = 2 * (secondChild + 1);
    }
    if (secondChild == len) {
	*(first + holeIndex) = *(first + (secondChild - 1));
	holeIndex = secondChild - 1;
    }
    __push_heap(first, holeIndex, topIndex, value);
}

template <class RandomAccessIterator, class T, class Distance>
inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		       RandomAccessIterator result, T value, Distance*) {
    *result = *first;
    __adjust_heap(first, Distance(0), Distance(last - first), value);
}

template <class RandomAccessIterator, class Distance, class T, class Compare>
void __adjust_heap(RandomAccessIterator first, Distance holeIndex,
		   Distance len, T value, Compare comp) {
    Distance topIndex = holeIndex;
    Distance secondChild = 2 * holeIndex + 2;
    while (secondChild < len) {
	if (comp(*(first + secondChild), *(first + (secondChild - 1))))
	    secondChild--;
	*(first + holeIndex) = *(first + secondChild);
	holeIndex = secondChild;
	secondChild = 2 * (secondChild + 1);
    }
    if (secondChild == len) {
	*(first + holeIndex) = *(first + (secondChild - 1));
	holeIndex = secondChild - 1;
    }
    __push_heap(first, holeIndex, topIndex, value, comp);
}

template <class RandomAccessIterator, class T, class Compare, class Distance>
inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,
		       RandomAccessIterator result, T value, Compare comp,
		       Distance*) {
    *result = *first;
    __adjust_heap(first, Distance(0), Distance(last - first), value, comp);
}

template <class RandomAccessIterator, class Distance, class T>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, Distance*, T*) {
    __push_heap(first, Distance((last - first) - 1), Distance(0), 
		T(*(last - 1)));
}

template <class RandomAccessIterator, class Compare, class Distance, class T>
inline void __push_heap_aux(RandomAccessIterator first,
			    RandomAccessIterator last, Compare comp,
			    Distance*, T*) {
    __push_heap(first, Distance((last - first) - 1), Distance(0), 
		T(*(last - 1)), comp);
}

template <class RandomAccessIterator, class T>
inline void __pop_heap_aux(RandomAccessIterator first,
			   RandomAccessIterator last, T*) {
    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), distance_type(first));
}

template <class RandomAccessIterator, class T, class Compare>
inline void __pop_heap_aux(RandomAccessIterator first,
			   RandomAccessIterator last, T*, Compare comp) {
    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), comp,
	       distance_type(first));
}

template <class RandomAccessIterator, class T, class Distance>
void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,
		 Distance*) {
    if (last - first < 2) return;
    Distance len = last - first;
    Distance parent = (len - 2)/2;
    
    while (true) {
	__adjust_heap(first, parent, len, T(*(first + parent)));
	if (parent == 0) return;
	parent--;
    }
}

template <class RandomAccessIterator, class Compare, class T, class Distance>
void __make_heap(RandomAccessIterator first, RandomAccessIterator last,
		 Compare comp, T*, Distance*) {
    if (last - first < 2) return;
    Distance len = last - first;
    Distance parent = (len - 2)/2;
    
    while (true) {
	__adjust_heap(first, parent, len, T(*(first + parent)), comp);
	if (parent == 0) return;
	parent--;
    }
}

template < class BI_ITER >
void __reverse( BI_ITER first, BI_ITER last, bidirectional_iterator_tag )
{
	for( ; ; )
	{
		if( first == last or first == --last )
			return;
		else
			iter_swap( first++, last );
	}
}

//////////////////////////////////////////////////////////////////////

template < class T >
void swap( T& a, T& b )
{
	T temp = a;
	a = b;
	b = temp;
}

//////////////////////////////////////////////////////////////////////

template < class InputIter, class Function >
Function
for_each( InputIter first, InputIter last, Function f )
{
	while( first != last )
		f( *first++ );

    return f;
}

//////////////////////////////////////////////////////////////////////

template < class InputIter, class T >
InputIter
find( InputIter first, InputIter last, const T& value )
{
	while( first != last and *first != value )
		++first;

    return first;
}

///////////////////////////////////

template < class InputIter, class Predicate >
InputIter find_if(	InputIter first,
					InputIter last,
					Predicate p )
{
	while( first != last and not p( *first ) )
		++first;

    return first;
}

//////////////////////////////////////////////////////////////////////

template < class InputIter >
InputIter adjacent_find( InputIter first, InputIter last )
{
	if( first == last )
		return last;

	InputIter next = first;

	while( ++next != last)
	{
		if( *first == *next )
			return first;

		first = next;
	}

    return last;
}

///////////////////////////////////

template < class InputIter, class BinaryPredicate >
InputIter adjacent_find(	InputIter first,
							InputIter last,
							BinaryPredicate p )
{
	if( first == last )
		return last;

	InputIter next = first;

	while( ++next != last )
	{
		if( p( *first, *next ) )
			return first;

		first = next;
	}

    return last;
}

//////////////////////////////////////////////////////////////////////

template < class InputIter, class T, class Size >
void count( InputIter first,
			InputIter last,
			const T& value,
			Size& n )
{
	while( first != last )
		if( *first++ == value)
			++n;
}

///////////////////////////////////

template < class InputIter, class Predicate, class Size >
void count_if(	InputIter first,
				InputIter last,
				Predicate p,
				Size& n )
{
	while( first != last )
		if( p( *first++ ) )
			++n;
}

//////////////////////////////////////////////////////////////////////

template < class InputIter1, class InputIter2 >
pair< InputIter1, InputIter2 >
mismatch(	InputIter1 first1,
			InputIter1 last1,
			InputIter2 first2 )
{
    while( first1 != last1 and *first1 == *first2 )
    {
		++first1;
		++first2;
    }

    return pair< InputIter1, InputIter2 >( first1, first2 );
}

///////////////////////////////////

template <	class InputIter1,
			class InputIter2,
			class BinaryPredicate >
pair< InputIter1, InputIter2 >
mismatch(	InputIter1 first1,
			InputIter1 last1,
			InputIter2 first2,
			BinaryPredicate p )
{
	while( first1 != last1 and p( *first1, *first2 ) )
	{
		++first1;
		++first2;
    }

    return pair< InputIter1, InputIter2>( first1, first2 );
}

//////////////////////////////////////////////////////////////////////

template < class InputIter1, class InputIter2 >
bool equal(	InputIter1 first1,
			InputIter1 last1,
			InputIter2 first2 )
{
    return mismatch( first1, last1, first2 ).first == last1;
}

///////////////////////////////////

template <	class InputIter1,
			class InputIter2,
			class BinaryPredicate >
bool equal(	InputIter1 first1,
			InputIter1 last1,
			InputIter2 first2,
			BinaryPredicate p )
{
    return mismatch( first1, last1, first2, p ).first == last1;
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIter1, class ForwardIter2 >
ForwardIter1 search(	ForwardIter1 first1,
						ForwardIter1 last1,
						ForwardIter2 first2,
						ForwardIter2 last2 )
{
    return __search( first1, last1, first2, last2, distance_type( first1 ) );
}

///////////////////////////////////

template < class InputIter, class OutputIter >
OutputIter copy( InputIter first, InputIter last, OutputIter result )
{
	while( first != last )
		*result++ = *first++;

    return result;
}

///////////////////////////////////

template < class BidirectionalIter1, class BidirectionalIter2 >
BidirectionalIter1
copy_backward(	BidirectionalIter1 first,
				BidirectionalIter1 last,
				BidirectionalIter2 result )
{
    while( first != last )
    	*--result = *--last;

    return result;
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIter1, class ForwardIter2 >
void iter_swap( ForwardIter1 a, ForwardIter2 b )
{
	__iter_swap( a, b, value_type( a ) );
}

//////////////////////////////////////////////////////////////////////

template <	class InputIter,
			class OutputIter,
			class UnaryOperation >
OutputIter
transform(	InputIter first,
			InputIter last,
			OutputIter result,
			UnaryOperation op )
{
    while( first != last )
    	*result++ = op( *first++ );

    return result;
}

///////////////////////////////////

template <	class InputIter1,
			class InputIter2,
			class OutputIter,
	  		class BinaryOperation >
OutputIter
transform(	InputIter1 first1,
			InputIter1 last1,
			InputIter2 first2,
			OutputIter result,
			BinaryOperation binary_op )
{
	while( first1 != last1 )
		*result++ = binary_op( *first1++, *first2++ );

    return result;
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIter, class T >
void replace(	ForwardIter first,
				ForwardIter last,
				const T& old_value,
	     		const T& new_value )
{
	while( first != last )
	{
		if( *first == old_value )
			*first = new_value;

		++first;
	}
}

///////////////////////////////////

template <	class ForwardIter,
			class Predicate,
			class T >
void replace_if(	ForwardIter first,
					ForwardIter last,
					Predicate pred,
					const T& new_value )
{
    while( first != last )
    {
		if( pred( *first ) )
			*first = new_value;

		++first;
    }
}

///////////////////////////////////

template <	class InputIter,
			class OutputIter,
			class T >
OutputIter
replace_copy(	InputIter first,
				InputIter last,
			    OutputIter result,
			    const T& old_value,
			    const T& new_value )
{
	while( first != last )
	{
		*result++ = *first == old_value
						? new_value
						: *first;

		++first;
    }

	return result;
}

///////////////////////////////////

template <	class Iter,
			class OutputIter,
			class Predicate,
			class T >
OutputIter
replace_copy_if(	Iter first,
					Iter last,
					OutputIter result,
					Predicate pred,
			       const T& new_value )
{
    while( first != last )
    {
		*result++ = pred(*first)
						? new_value
						: *first;

		++first;
    }

    return result;
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIter, class T >
void fill(	ForwardIter first,
			ForwardIter last,
			const T& value )
{
	while( first != last )
		*first++ = value;
}

///////////////////////////////////

template <	class OutputIter,
			class Size,
			class T >
void fill_n(	OutputIter first,
				Size n,
				const T& value )
{
	while( n-- > 0 )
		*first++ = value;
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIter, class Generator >
void generate(	ForwardIter first,
				ForwardIter last,
				Generator gen )
{
	while( first != last )
		*first++ = gen();
}

///////////////////////////////////

template < class OutputIter, class Size, class Generator >
void generate_n( OutputIter first, Size n, Generator gen )
{
	while( n-- > 0 )
		*first++ = gen();
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIterator, class T >
ForwardIterator remove(	ForwardIterator first,
						ForwardIterator last,
		       			const T& value )
{
    first = find( first, last, value );
    ForwardIterator next = first;
    return first == last ? first
			: remove_copy( ++next, last, first, value );
}

///////////////////////////////////

template < class ForwardIterator, class Predicate >
ForwardIterator
remove_if(	ForwardIterator first,
			ForwardIterator last,
			Predicate pred )
{
    first = find_if( first, last, pred );
    ForwardIterator next = first;
    return first == last ? first
    						: remove_copy_if( ++next, last, first, pred );
}

///////////////////////////////////

template < class InputIter, class OutputIter, class T >
OutputIter
remove_copy(	InputIter first,
				InputIter last,
				OutputIter result,
				const T& value )
{
	while( first != last )
	{
		if( *first != value )
			*result++ = *first;

		++first;
    }

    return result;
}

///////////////////////////////////

template <	class InputIterator,
			class OutputIterator,
			class Predicate >
OutputIterator
remove_copy_if(	InputIterator first,
				InputIterator last,
				OutputIterator result,
				Predicate pred )
{
	while( first != last )
	{
		if( not pred( *first ) )
			*result++ = *first;

		++first;
    }

    return result;
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIterator >
ForwardIterator unique( ForwardIterator first, ForwardIterator last )
{
    first = adjacent_find( first, last );
    return unique_copy( first, last, first );
}

///////////////////////////////////

template < class ForwardIterator, class BinaryPredicate >
ForwardIterator
unique(	ForwardIterator first,
		ForwardIterator last,
		BinaryPredicate binary_pred )
{
    first = adjacent_find( first, last, binary_pred );
    return unique_copy( first, last, first, binary_pred );
}

///////////////////////////////////

template <	class InputIterator,
			class OutputIterator,
			class BinaryPredicate >
OutputIterator
unique_copy(	InputIterator first,
				InputIterator last,
				OutputIterator result,
				BinaryPredicate p )
{
	if( first == last )
		return result;

    return __unique_copy( first, last, result, p,
			 				iterator_category( result ) );
}

//////////////////////////////////////////////////////////////////////

template < class BidirectionalIterator >
void reverse( BidirectionalIterator first, BidirectionalIterator last )
{
	__reverse( first, last, iterator_category( first ) );
}

///////////////////////////////////

template < class BidirectionalIterator, class OutputIterator >
OutputIterator
reverse_copy(	BidirectionalIterator first,
				BidirectionalIterator last,
				OutputIterator result )
{
	while( first != last )
		*result++ = *--last;

    return result;
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIterator >
void rotate(	ForwardIterator first,
				ForwardIterator middle,
				ForwardIterator last )
{
	if( first == middle or middle == last )
		return;

    __rotate( first, middle, last, distance_type( first ),
				iterator_category( first ) );
}

///////////////////////////////////

template < class ForwardIterator, class OutputIterator >
OutputIterator
rotate_copy(	ForwardIterator first,
				ForwardIterator middle,
				ForwardIterator last,
				OutputIterator result )
{
	return copy( first, middle, copy( middle, last, result ) );
}

//////////////////////////////////////////////////////////////////////

template < class RandomAccessIterator >
void random_shuffle(	RandomAccessIterator first,
			   			RandomAccessIterator last )
{
	__random_shuffle( first, last, distance_type( first ) );
}

///////////////////////////////////

template < class RandomAccessIterator, class RandomNumberGenerator >
void
random_shuffle(	RandomAccessIterator first,
				RandomAccessIterator last,
		    	RandomNumberGenerator& rand )
{
	if( first == last )
		return;

    for( RandomAccessIterator i = first + 1; i != last; ++i )
		iter_swap( i, first + rand( (i - first) + 1 ) );
}

//////////////////////////////////////////////////////////////////////

template < class BidirectionalIterator, class Predicate >
BidirectionalIterator
partition(	BidirectionalIterator first,
			BidirectionalIterator last,
			Predicate pred )
{
    while( true )
    {
		while( true )
		{
	    	if( first == last )
				return first;
	    	else if( pred( *first) )
				++first;
	    	else
				break;
		}

		--last;

		while( true )
		{
	    	if( first == last )
				return first;
	    	else if ( not pred( *last ) )
				--last;
	    	else
				break;
		}

		iter_swap( first, last );
		++first;
    }
}

///////////////////////////////////

template < class ForwardIterator, class Predicate >
ForwardIterator
stable_partition(	ForwardIterator first,
					ForwardIterator last, 
					Predicate pred )
{
	return __stable_partition_aux( first, last, pred, distance_type( first ) );
}

//////////////////////////////////////////////////////////////////////

template < class RandomAccessIterator >
void sort(	RandomAccessIterator first,
			RandomAccessIterator last )
{
	__quick_sort_loop( first, last );
	__final_insertion_sort( first, last );
}

///////////////////////////////////

template < class RandomAccessIterator, class Compare >
void sort(	RandomAccessIterator first,
			RandomAccessIterator last,
			Compare comp )
{
	__quick_sort_loop( first, last, comp );
	__final_insertion_sort( first, last, comp );
}


//////////////////////////////////////////////////////////////////////

template < class RandomAccessIterator >
void
stable_sort(	RandomAccessIterator first,
				RandomAccessIterator last )
{
	__stable_sort_aux( first, last, distance_type( first ) );
}

///////////////////////////////////

template < class RandomAccessIterator, class Compare >
void
stable_sort(	RandomAccessIterator first,
				RandomAccessIterator last,
				Compare comp )
{
	__stable_sort_aux( first, last, distance_type( first ), comp );
}

//////////////////////////////////////////////////////////////////////

template <class RandomAccessIterator>
void
partial_sort(	RandomAccessIterator first,
				RandomAccessIterator middle,
				RandomAccessIterator last )
{
	__partial_sort( first, middle, last, value_type( first ) );
}

///////////////////////////////////

template < class RandomAccessIterator, class Compare >
void
partial_sort(	RandomAccessIterator first,
			 	RandomAccessIterator middle,
			 	RandomAccessIterator last,
			 	Compare comp )
{
	__partial_sort( first, middle, last, value_type( first ), comp );
}

///////////////////////////////////

template < class InputIterator, class RandomAccessIterator >
RandomAccessIterator
partial_sort_copy(	InputIterator first,
					InputIterator last,
		  			RandomAccessIterator result_first,
		  			RandomAccessIterator result_last )
{
	return __partial_sort_copy( first, last,
								result_first,
								result_last, 
			       				distance_type( result_first ),
			       				value_type( first ) );
}

///////////////////////////////////

template <	class InputIterator,
			class RandomAccessIterator,
			class Compare >
RandomAccessIterator
partial_sort_copy(	InputIterator first,
					InputIterator last,
		  			RandomAccessIterator result_first,
		  			RandomAccessIterator result_last,
		  			Compare comp )
{
	return __partial_sort_copy( first, last,
								result_first,
								result_last,
								comp,
			       				distance_type( result_first ),
			       				value_type( first ) );
}

//////////////////////////////////////////////////////////////////////

template < class RandomAccessIterator >
void
nth_element(	RandomAccessIterator first,
				RandomAccessIterator nth,
				RandomAccessIterator last )
{
	__nth_element( first, nth, last, value_type( first ) );
}

///////////////////////////////////

template < class RandomAccessIterator, class Compare >
void
nth_element(	RandomAccessIterator first,
				RandomAccessIterator nth,
		 		RandomAccessIterator last,
		 		Compare comp )
{
    __nth_element( first, nth, last, value_type( first ), comp );
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIterator, class T >
ForwardIterator
lower_bound(	ForwardIterator first,
				ForwardIterator last,
				const T& value )
{
    return __lower_bound( first, last, value,
    						distance_type( first ),
			 				iterator_category( first ) );
}

///////////////////////////////////

template < class ForwardIterator, class T, class Compare >
ForwardIterator
lower_bound(	ForwardIterator first,
				ForwardIterator last,
				const T& value,
				Compare comp )
{
	return __lower_bound( first, last, value,
							comp, distance_type( first ),
							iterator_category( first ) );
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIterator, class T >
ForwardIterator
upper_bound(	ForwardIterator first,
				ForwardIterator last,
				const T& value )
{
    return __upper_bound( first, last, value,
    						distance_type( first ),
			 				iterator_category( first ) );
}

///////////////////////////////////

template < class ForwardIterator, class T, class Compare >
ForwardIterator
upper_bound(	ForwardIterator first,
				ForwardIterator last,
				const T& value,
				Compare comp )
{
	return __upper_bound( first, last, value, comp,
							distance_type( first ),
			 				iterator_category( first ) );
}

//////////////////////////////////////////////////////////////////////

template < class ForwardIterator, class T >
pair< ForwardIterator, ForwardIterator >
equal_range(	ForwardIterator first,
				ForwardIterator last,
				const T& value )
{
    return __equal_range( first, last, value,
    						distance_type( first ),
			 				iterator_category( first ) );
}

///////////////////////////////////

template <	class ForwardIterator,
			class T,
			class Compare >
pair< ForwardIterator, ForwardIterator >
equal_range(	ForwardIterator first,
				ForwardIterator last,
				const T& value,
	    		Compare comp )
{
	return __equal_range( first, last, value, comp,
							distance_type( first ),
							iterator_category( first ) );
}    

//////////////////////////////////////////////////////////////////////

template < class ForwardIterator, class T >
bool
binary_search(	ForwardIterator first,
				ForwardIterator last,
		   		const T& value )
{
	ForwardIterator i = lower_bound( first, last, value );
    return i != last and not ( value < *i );
}

///////////////////////////////////

template <	class ForwardIterator,
			class T,
			class Compare >
bool binary_search(	ForwardIterator first,
					ForwardIterator last,
					const T& value,
		   			Compare comp )
{
	ForwardIterator i = lower_bound( first, last, value, comp );
    return i != last and not comp( value, *i );
}

//////////////////////////////////////////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator >
OutputIterator
merge(	InputIterator1 first1,
		InputIterator1 last1,
		InputIterator2 first2,
		InputIterator2 last2,
		OutputIterator result )
{
	while( first1 != last1 and first2 != last2 )
		if( *first2 < *first1 )
	    	*result++ = *first2++;
	else
	    *result++ = *first1++;

    return copy( first2, last2, copy( first1, last1, result ) );
}

///////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator,
	  		class Compare >
OutputIterator
merge(	InputIterator1 first1,
		InputIterator1 last1,
		InputIterator2 first2,
		InputIterator2 last2,
		OutputIterator result,
		Compare comp )
{
    while( first1 != last1 and first2 != last2 )
	{
		if( comp( *first2, *first1 ) )
	    	*result++ = *first2++;
		else
	    	*result++ = *first1++;
	}

    return copy( first2, last2, copy( first1, last1, result ) );
}

//////////////////////////////////////////////////////////////////////

template < class BidirectionalIterator >
void
inplace_merge(	BidirectionalIterator first,
			  	BidirectionalIterator middle,
			  	BidirectionalIterator last )
{
	__inplace_merge_aux( first, middle, last,
							distance_type( first ) );
}

///////////////////////////////////

template < class BidirectionalIterator, class Compare >
void
inplace_merge(	BidirectionalIterator first,
			  	BidirectionalIterator middle,
			  	BidirectionalIterator last,
			  	Compare comp )
{
	__inplace_merge_aux( first, middle, last,
							distance_type( first ), comp );
}

//////////////////////////////////////////////////////////////////////

template < class InputIterator1, class InputIterator2 >
bool
includes(	InputIterator1 first1,
			InputIterator1 last1,
	      	InputIterator2 first2,
	      	InputIterator2 last2 )
{
    while( first1 != last1 and first2 != last2 )
	{
		if( *first2 < *first1 )
	    	return false;
		else if( *first1 < *first2 ) 
	    	++first1;
		else
	    	++first1, ++first2;
	}

	return first2 == last2;
}

///////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class Compare >
bool
includes(	InputIterator1 first1,
			InputIterator1 last1,
	      	InputIterator2 first2,
	      	InputIterator2 last2,
	      	Compare comp )
{
    while( first1 != last1 and first2 != last2 )
	{
		if( comp( *first2, *first1 ) )
	    	return false;
		else if( comp( *first1, *first2 ) ) 
	    	++first1;
		else
	    	++first1, ++first2;
	}

	return first2 == last2;
}

//////////////////////////////////////////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator >
OutputIterator
set_union(	InputIterator1 first1,
			InputIterator1 last1,
			InputIterator2 first2,
			InputIterator2 last2,
			OutputIterator result )
{
    while (first1 != last1 && first2 != last2)
	{
		if( *first1 < *first2 )
			*result++ = *first1++;
		else if( *first2 < *first1 )
	    	*result++ = *first2++;
		else
		{
	    	*result++ = *first1++;
	    	first2++;
		}
	}

    return copy( first2, last2, copy( first1, last1, result ) );
}

///////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator,
	  		class Compare >
OutputIterator
set_union(	InputIterator1 first1,
			InputIterator1 last1,
			InputIterator2 first2,
			InputIterator2 last2,
			OutputIterator result,
			Compare comp )
{
    while( first1 != last1 and first2 != last2 )
	{
		if( comp( *first1, *first2 ) )
	    	*result++ = *first1++;
		else if( comp( *first2, *first1 ) )
	    	*result++ = *first2++;
		else
		{
	    	*result++ = *first1++;
	    	++first2;
		}
	}

	return copy( first2, last2, copy( first1, last1, result ) );
}

//////////////////////////////////////////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator >
OutputIterator
set_intersection(	InputIterator1 first1,
					InputIterator1 last1,
					InputIterator2 first2,
					InputIterator2 last2,
					OutputIterator result )
{
	while( first1 != last1 and first2 != last2 )
	{
		if( *first1 < *first2 )
	    	++first1;
		else if( *first2 < *first1 )
	    	++first2;
		else
		{
	    	*result++ = *first1++;
	    	++first2;
		}
	}

    return result;
}

///////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator,
	  		class Compare >
OutputIterator
set_intersection(	InputIterator1 first1,
					InputIterator1 last1,
					InputIterator2 first2,
					InputIterator2 last2,
					OutputIterator result,
					Compare comp )
{
	while( first1 != last1 and first2 != last2 )
	{
		if( comp( *first1, *first2 ) )
	    	++first1;
		else if( comp( *first2, *first1 ) )
	    	++first2;
		else
		{
	    	*result++ = *first1++;
	    	++first2;
		}
	}

    return result;
}

//////////////////////////////////////////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator >
OutputIterator
set_difference(	InputIterator1 first1,
				InputIterator1 last1,
				InputIterator2 first2,
				InputIterator2 last2,
				OutputIterator result )
{
	while( first1 != last1 and first2 != last2 )
	{
		if( *first1 < *first2 )
	    	*result++ = *first1++;
		else if( *first2 < *first1 )
	    	++first2;
		else
		{
	    	++first1;
	    	++first2;
		}
	}

    return copy( first1, last1, result );
}

///////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator, 
	  		class Compare >
OutputIterator
set_difference(	InputIterator1 first1,
				InputIterator1 last1,
				InputIterator2 first2,
				InputIterator2 last2, 
				OutputIterator result,
				Compare comp )
{
    while( first1 != last1 and first2 != last2 )
	{
		if( comp( *first1, *first2 ) )
	    	*result++ = *first1++;
		else if( comp( *first2, *first1 ) )
	    	++first2;
		else
		{
	    	++first1;
	    	++first2;
		}
	}

	return copy( first1, last1, result );
}

//////////////////////////////////////////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator >
OutputIterator
set_symmetric_difference(	InputIterator1 first1,
							InputIterator1 last1,
							InputIterator2 first2,
							InputIterator2 last2,
							OutputIterator result )
{
	while( first1 != last1 and first2 != last2 )
	{
		if( *first1 < *first2 )
	    	*result++ = *first1++;
		else if( *first2 < *first1 )
	    	*result++ = *first2++;
		else
		{
	    	++first1;
	    	++first2;
		}
	}

    return copy( first2, last2, copy( first1, last1, result ) );
}

///////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class OutputIterator,
	  		class Compare >
OutputIterator
set_symmetric_difference(	InputIterator1 first1,
							InputIterator1 last1,
							InputIterator2 first2,
							InputIterator2 last2,
							OutputIterator result,
							Compare comp )
{
	while( first1 != last1 and first2 != last2 )
	{
		if( comp( *first1, *first2 ) )
	    	*result++ = *first1++;
		else if( comp( *first2, *first1 ) )
	    	*result++ = *first2++;
		else
		{
	    	++first1;
	    	++first2;
		}
	}

    return copy( first2, last2, copy( first1, last1, result ) );
}

//////////////////////////////////////////////////////////////////////

template < class RandomAccessIterator >
void
push_heap(	RandomAccessIterator first,
			RandomAccessIterator last )
{
	__push_heap_aux( first, last, distance_type( first ), value_type( first ) );
}

template < class RandomAccessIterator, class Compare >
void
push_heap(	RandomAccessIterator first,
			RandomAccessIterator last,
			Compare comp )
{
	__push_heap_aux( first, last, comp, distance_type( first ), value_type( first ) );
}

///////////////////////////////////

template < class RandomAccessIterator >
void pop_heap(	RandomAccessIterator first,
				RandomAccessIterator last )
{
	__pop_heap_aux( first, last, value_type( first ) );
}

template <	class RandomAccessIterator, class Compare >
void
pop_heap(	RandomAccessIterator first,
			RandomAccessIterator last,
			Compare comp )
{
	__pop_heap_aux( first, last, value_type( first ), comp );
}

///////////////////////////////////

template < class RandomAccessIterator >
void make_heap(	RandomAccessIterator first,
				RandomAccessIterator last )
{
	__make_heap( first, last,
					value_type( first ),
					distance_type( first ) );
}

template < class RandomAccessIterator, class Compare >
void make_heap(	RandomAccessIterator first,
				RandomAccessIterator last,
		      	Compare comp )
{
	__make_heap( first, last, comp,
					value_type( first ),
					distance_type( first ) );
}

///////////////////////////////////

template < class RandomAccessIterator >
void
sort_heap(	RandomAccessIterator first,
			RandomAccessIterator last )
{
	while( last - first > 1 )
		pop_heap( first, last-- );
}

template < class RandomAccessIterator, class Compare >
void sort_heap(	RandomAccessIterator first,
				RandomAccessIterator last,
	       		Compare comp )
{
	while( last - first > 1 )
		pop_heap( first, last--, comp );
}

//////////////////////////////////////////////////////////////////////

template < class T >
const T& min( const T& a, const T& b )
{
	return b < a ? b : a;
}

template < class T >
const T& max( const T& a, const T& b )
{
    return  a < b ? b : a;
}

///////////////////////////////////

template < class T, class Compare >
const T& min( const T& a, const T& b, Compare comp )
{
    return comp( b, a ) ? b : a;
}

///////////////////////////////////

template < class T, class Compare >
const T& max( const T& a, const T& b, Compare comp )
{
    return comp( a, b ) ? b : a;
}

//////////////////////////////////////////////////////////////////////

template < class InputIterator >
InputIterator
min_element(	InputIterator first,
				InputIterator last )
{
	if( first == last )
		return first;

    InputIterator result = first;
    while( ++first != last ) 
		if( *first < *result )
			result = first;

    return result;
}

///////////////////////////////////

template < class InputIterator, class Compare >
InputIterator
min_element(	InputIterator first,
				InputIterator last,
			  	Compare comp )
{
	if( first == last )
		return first;

    InputIterator result = first;
    while( ++first != last ) 
		if( comp( *first, *result ) )
			result = first;

    return result;
}

//////////////////////////////////////////////////////////////////////

template < class InputIterator >
InputIterator
max_element( InputIterator first, InputIterator last )
{
	if( first == last )
		return first;

    InputIterator result = first;
    while( ++first != last ) 
		if( *result < *first )
			result = first;

    return result;
}

///////////////////////////////////

template < class InputIterator, class Compare >
InputIterator
max_element(	InputIterator first,
				InputIterator last,
			  	Compare comp )
{
	if( first == last )
		return first;

    InputIterator result = first;
    while( ++first != last ) 
		if( comp( *result, *first ) )
			result = first;

    return result;
}

//////////////////////////////////////////////////////////////////////

template < class InputIterator1, class InputIterator2 >
bool
lexicographical_compare(	InputIterator1 first1,
							InputIterator1 last1,
			     			InputIterator2 first2,
			     			InputIterator2 last2 )
{
	while( first1 != last1 && first2 != last2 )
	{
		if( *first1 < *first2 )
			return true;

		if( *first2++ < *first1++ )
			return false;
    }

    return first1 == last1 and first2 != last2;
}

///////////////////////////////////

template <	class InputIterator1,
			class InputIterator2,
			class Compare >
bool
lexicographical_compare(	InputIterator1 first1,
							InputIterator1 last1,
			     			InputIterator2 first2,
			     			InputIterator2 last2,
			     			Compare comp )
{
	while( first1 != last1 and first2 != last2 )
	{
		if( comp( *first1, *first2 ) )
			return true;

		if( comp( *first2++, *first1++ ) )
			return false;
    }

    return first1 == last1 and first2 != last2;
}

//////////////////////////////////////////////////////////////////////

template < class BidirectionalIterator >
bool
next_permutation(	BidirectionalIterator first,  
					BidirectionalIterator last )
{
	if( first == last )
		return false;

    BidirectionalIterator i = first;
    ++i;
    if( i == last )
    	return false;

    i = last;
    --i;

    for( ; ; )
    {
		BidirectionalIterator ii = i--;
		if( *i < *ii )
		{
	    	BidirectionalIterator j = last;
	    	while( not ( *i < *--j ) )
	    			;

	    	iter_swap( i, j );
	    	reverse( ii, last );
	    	return true;
		}

		if( i == first )
		{
	    	reverse(first, last);
	    	return false;
		}
    }
}

///////////////////////////////////

template <	class BidirectionalIterator,
			class Compare >
bool
next_permutation(	BidirectionalIterator first,
					BidirectionalIterator last,
		      		Compare comp )
{
	if( first == last )
		return false;

    BidirectionalIterator i = first;
    ++i;
    if( i == last )
    	return false;

    i = last;
    --i;

    for( ; ; )
    {
		BidirectionalIterator ii = i--;
		if( comp( *i, *ii) )
		{
	    	BidirectionalIterator j = last;
	    	while( not comp( *i, *--j ) )
	    		;

	    	iter_swap( i, j );
	    	reverse( ii, last );
	    	return true;
		}

		if( i == first )
		{
			reverse(first, last);
			return false;
		}
    }
}

///////////////////////////////////

template < class BidirectionalIterator >
bool
prev_permutation(	BidirectionalIterator first,
		      		BidirectionalIterator last )
{
	if( first == last )
		return false;

    BidirectionalIterator i = first;
    ++i;

    if( i == last )
    	return false;

    i = last;
    --i;

    for( ; ; )
    {
		BidirectionalIterator ii = i--;
		if( not ( *i < *ii ) )
		{
	    	BidirectionalIterator j = last;
	    	while( *i < *--j )
				;

	    	iter_swap( i, j );
	    	reverse( ii, last );
	    	return true;
		}

		if( i == first )
		{
	    	reverse( first, last );
	    	return false;
		}
	}
}

///////////////////////////////////

template < class BidirectionalIterator, class Compare >
bool
prev_permutation(	BidirectionalIterator first,
					BidirectionalIterator last,
		      		Compare comp )
{
	if( first == last )
		return false;

    BidirectionalIterator i = first;
    ++i;
    if( i == last )
    	return false;

    i = last;
    --i;

    for( ; ; )
    {
		BidirectionalIterator ii = i--;
		if( not comp( *i, *ii ) )
		{
	    	BidirectionalIterator j = last;
	    	while( comp( *i, *--j ) )
	    		;

	    	iter_swap( i, j );
	    	reverse( ii, last );
	    	return true;
		}

		if( i == first )
		{
	    	reverse( first, last );
	    	return false;
		}
    }
}

//////////////////////////////////////////////////////////////////////

const int __stl_threshold = 16;

//////////////////////////////////////////////////////////////////////

template < class RandomAccessIterator, class T >
RandomAccessIterator
__unguarded_partition(	RandomAccessIterator first, 
					   	RandomAccessIterator last, 
					   	T pivot )
{
    while( 1 )
    {
		while (*first < pivot) ++first;
			--last;

		while (pivot < *last)
			--last;

		if( !(first < last) )
			return first;

		iter_swap( first, last );
		++first;
    }
}    

template < class RandomAccessIterator,
			class T,
			class Compare >
RandomAccessIterator 
__unguarded_partition(	RandomAccessIterator first, 
					   	RandomAccessIterator last, 
					   	T pivot, 
					   	Compare comp )
{
    while( 1 )
    {
		while( comp( *first, pivot ) )
			++first;

		--last;
		while( comp( pivot, *last ) )
			--last;

		if( !( first < last ) )
			return first;

		iter_swap( first, last );
		++first;
    }
}

//////////////////////////////////////////////////////////////////////

template <class RandomAccessIterator, class T>
void __unguarded_linear_insert(RandomAccessIterator last, T value) {
    RandomAccessIterator next = last;
    --next;
    while (value < *next) {
	*last = *next;
	last = next--;
    }
    *last = value;
}

template <class RandomAccessIterator, class T, class Compare>
void __unguarded_linear_insert(RandomAccessIterator last, T value, 
			       Compare comp) {
    RandomAccessIterator next = last;
    --next;  
    while (comp(value , *next)) {
	*last = *next;
	last = next--;
    }
    *last = value;
}

//////////////////////////////////////////////////////////////////////

template < class RandomAccessIterator >
void 
__insertion_sort(	RandomAccessIterator first, 
					RandomAccessIterator last )
{
    if( first == last )
    	return;

    for( RandomAccessIterator i = first + 1; i != last; ++i )
		__linear_insert( first, i, value_type( first ) );
}

template < class RandomAccessIterator, class Compare >
void 
__insertion_sort(	RandomAccessIterator first,
		      		RandomAccessIterator last, 
		      		Compare comp )
{
    if( first == last )
    	return;

    for( RandomAccessIterator i = first + 1; i != last; ++i )
		__linear_insert( first, i, value_type( first ), comp );
}

//////////////////////////////////////////////////////////////////////

template < class RandomAccessIterator, class T >
void
__unguarded_insertion_sort_aux(	RandomAccessIterator first, 
				    			RandomAccessIterator last,
				    			T * )
{
    for( RandomAccessIterator i = first; i != last; ++i )
		__unguarded_linear_insert( i, T( *i ) );
}

template < class RandomAccessIterator, class T, class Compare >
void 
__unguarded_insertion_sort_aux(	RandomAccessIterator first, 
				    			RandomAccessIterator last,
				    			T *,
				    			Compare comp )
{
	for( RandomAccessIterator i = first; i != last; ++i )
		__unguarded_linear_insert( i, T(*i), comp );
}

//////////////////////////////////////////////////////////////////////

template < class RandomAccessIterator, class T >
void 
__quick_sort_loop_aux( RandomAccessIterator first,
			   			RandomAccessIterator last, 
			   			T * )
{
	while( last - first > __stl_threshold )
	{
		RandomAccessIterator cut = 
			__unguarded_partition( first, 
					last, 
					T( __median(*first, *(first + (last - first) / 2 ),
				     *(last - 1))));

		if( cut - first >= last - cut )
		{
		    __quick_sort_loop( cut, last );
		    last = cut;
		}
		else 
		{
		    __quick_sort_loop( first, cut );
		    first = cut;
		}
    }
}

template < class RandomAccessIterator, class T, class Compare >
void 
__quick_sort_loop_aux(	RandomAccessIterator first, 
			   			RandomAccessIterator last, 
			   			T*, 
			   			Compare comp )
{
    while( last - first > __stl_threshold )
    {
		RandomAccessIterator cut = 
		__unguarded_partition( first, last, 
								T(__median(*first, *(first + (last - first)/2), 
				   				*(last - 1), comp ) ), comp );
		if( cut - first >= last - cut )
		{
	    	__quick_sort_loop(cut, last, comp);
		    last = cut;
		}
		else 
		{
		    __quick_sort_loop(first, cut, comp);
		    first = cut;
		}
    }
}

template < class RandomAccessIterator >
void 
__final_insertion_sort( RandomAccessIterator first, 
			    		RandomAccessIterator last )
{
    if( last - first > __stl_threshold )
    {
		__insertion_sort( first, first + __stl_threshold );
		__unguarded_insertion_sort( first + __stl_threshold, last );
    }
    else
		__insertion_sort( first, last );
}

template < class RandomAccessIterator, class Compare >
void 
__final_insertion_sort(	RandomAccessIterator first, 
			    		RandomAccessIterator last, 
			    		Compare comp )
{
	if( last - first > __stl_threshold )
	{
		__insertion_sort( first, first + __stl_threshold, comp );
		__unguarded_insertion_sort( first + __stl_threshold, last, comp );
    }
    else
		__insertion_sort( first, last, comp );
}

/* End ALGORITHM.CTF ************************************************/

